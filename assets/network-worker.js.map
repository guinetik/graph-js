{"version":3,"file":"network-worker.js","sources":["../src/compute/network-worker.js"],"sourcesContent":["/**\r\n * Network Worker - Executes compute functions from algorithm modules\r\n *\r\n * **Bundler-Friendly Architecture:**\r\n * - Statically imports all algorithm modules upfront\r\n * - Creates a registry that maps module paths to their exports\r\n * - Main thread sends: { id, module, functionName, args }\r\n * - Worker looks up module from registry and executes function\r\n *\r\n * This approach works with all bundlers (Vite, Webpack, Rollup) because\r\n * imports are known at build time.\r\n *\r\n * @module network-worker\r\n */\r\n\r\nimport { createLogger } from '@guinetik/logger';\r\n\r\n// ============================================================================\r\n// STATIC IMPORTS - All algorithm modules imported upfront\r\n// ============================================================================\r\n\r\n// Create logger for worker (runs in separate context, no window.logFilter)\r\nconst log = createLogger({\r\n  prefix: 'network-worker',\r\n  level: 'info' // Workers default to info level\r\n});\r\n\r\n// Statistics algorithms (node-level and graph-level)\r\nimport * as nodeStatsCompute from '../statistics/algorithms/node-stats.js';\r\nimport * as graphStatsCompute from '../statistics/algorithms/graph-stats.js';\r\n\r\n// Community detection algorithms\r\nimport * as louvainCompute from '../community/algorithms/louvain.js';\r\n\r\n// Layout algorithms\r\nimport * as randomCompute from '../layouts/random.js';\r\nimport * as circularCompute from '../layouts/circular.js';\r\nimport * as spiralCompute from '../layouts/spiral.js';\r\nimport * as shellCompute from '../layouts/shell.js';\r\nimport * as spectralCompute from '../layouts/spectral.js';\r\nimport * as forceDirectedCompute from '../layouts/force-directed.js';\r\nimport * as kamadaKawaiCompute from '../layouts/kamada-kawai.js';\r\nimport * as bipartiteCompute from '../layouts/bipartite.js';\r\nimport * as multipartiteCompute from '../layouts/multipartite.js';\r\nimport * as bfsCompute from '../layouts/bfs.js';\r\n\r\n// ============================================================================\r\n// MODULE REGISTRY - Maps module paths to their exports\r\n// ============================================================================\r\n\r\nconst MODULE_REGISTRY = {\r\n  // Node-level statistics (all in one file)\r\n  '../statistics/algorithms/node-stats.js': nodeStatsCompute,\r\n\r\n  // Graph-level statistics\r\n  '../statistics/algorithms/graph-stats.js': graphStatsCompute,\r\n\r\n  // Community\r\n  '../community/algorithms/louvain.js': louvainCompute,\r\n\r\n  // Layouts\r\n  '../layouts/random.js': randomCompute,\r\n  '../layouts/circular.js': circularCompute,\r\n  '../layouts/spiral.js': spiralCompute,\r\n  '../layouts/shell.js': shellCompute,\r\n  '../layouts/spectral.js': spectralCompute,\r\n  '../layouts/force-directed.js': forceDirectedCompute,\r\n  '../layouts/kamada-kawai.js': kamadaKawaiCompute,\r\n  '../layouts/bipartite.js': bipartiteCompute,\r\n  '../layouts/multipartite.js': multipartiteCompute,\r\n  '../layouts/bfs.js': bfsCompute\r\n};\r\n\r\n// ============================================================================\r\n// WORKER MESSAGE HANDLER\r\n// ============================================================================\r\n\r\n/**\r\n * Main message handler - receives tasks and delegates to algorithm modules\r\n */\r\nself.onmessage = async function(event) {\r\n  const { id, module, functionName, args = [] } = event.data;\r\n\r\n  try {\r\n    // Validate message format\r\n    if (!module || !functionName) {\r\n      throw new Error('Invalid task: module and functionName are required');\r\n    }\r\n\r\n    log.debug('Processing task', {\r\n      id,\r\n      module,\r\n      functionName,\r\n      argsLength: args?.length || 0\r\n    });\r\n\r\n    // Create progress callback that reports back to main thread\r\n    const progressCallback = (progress) => {\r\n      self.postMessage({\r\n        id,\r\n        status: 'progress',\r\n        progress: Math.min(Math.max(progress, 0), 1) // Clamp to [0, 1]\r\n      });\r\n    };\r\n\r\n    // Look up algorithm module from registry\r\n    const algorithmModule = MODULE_REGISTRY[module];\r\n\r\n    if (!algorithmModule) {\r\n      throw new Error(\r\n        `Module '${module}' not found in registry. ` +\r\n        `Available modules: ${Object.keys(MODULE_REGISTRY).join(', ')}`\r\n      );\r\n    }\r\n\r\n    // Get the compute function\r\n    const computeFunction = algorithmModule[functionName];\r\n\r\n    if (!computeFunction || typeof computeFunction !== 'function') {\r\n      throw new Error(\r\n        `Function '${functionName}' not found in module '${module}'. ` +\r\n        `Available functions: ${Object.keys(algorithmModule).join(', ')}`\r\n      );\r\n    }\r\n\r\n    // Execute the compute function\r\n    // Last arg is always the progress callback\r\n    const result = await computeFunction(...args, progressCallback);\r\n\r\n    // Send successful result\r\n    self.postMessage({\r\n      id,\r\n      status: 'complete',\r\n      result\r\n    });\r\n\r\n  } catch (error) {\r\n    // Send error\r\n    log.error('Task failed', {\r\n      id,\r\n      error: error.message,\r\n      stack: error.stack\r\n    });\r\n    self.postMessage({\r\n      id,\r\n      status: 'error',\r\n      error: error.message || 'Unknown error',\r\n      stack: error.stack\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Handle worker errors\r\n */\r\nself.onerror = function(error) {\r\n  log.error('Worker error', {\r\n    error: error.message || 'Worker error occurred',\r\n    stack: error.stack\r\n  });\r\n  self.postMessage({\r\n    status: 'error',\r\n    error: error.message || 'Worker error occurred'\r\n  });\r\n};\r\n\r\n// Log worker initialization\r\nlog.info('Initialized', { moduleCount: Object.keys(MODULE_REGISTRY).length });\r\n"],"names":["log","createLogger","MODULE_REGISTRY","nodeStatsCompute","graphStatsCompute","louvainCompute","randomCompute","circularCompute","spiralCompute","shellCompute","spectralCompute","forceDirectedCompute","kamadaKawaiCompute","bipartiteCompute","multipartiteCompute","bfsCompute","event","id","module","functionName","args","progressCallback","progress","algorithmModule","computeFunction","result","error"],"mappings":";;AAsBA,MAAMA,IAAMC,EAAa;AAAA,EACvB,QAAQ;AAAA,EACR,OAAO;AAAA;AACT,CAAC,GAyBKC,IAAkB;AAAA;AAAA,EAEtB,0CAA0CC;AAAA;AAAA,EAG1C,2CAA2CC;AAAA;AAAA,EAG3C,sCAAsCC;AAAA;AAAA,EAGtC,wBAAwBC;AAAA,EACxB,0BAA0BC;AAAA,EAC1B,wBAAwBC;AAAA,EACxB,uBAAuBC;AAAA,EACvB,0BAA0BC;AAAA,EAC1B,gCAAgCC;AAAA,EAChC,8BAA8BC;AAAA,EAC9B,2BAA2BC;AAAA,EAC3B,8BAA8BC;AAAA,EAC9B,qBAAqBC;AACvB;AASA,KAAK,YAAY,eAAeC,GAAO;AACrC,QAAM,EAAE,IAAAC,GAAI,QAAAC,GAAQ,cAAAC,GAAc,MAAAC,IAAO,GAAE,IAAKJ,EAAM;AAEtD,MAAI;AAEF,QAAI,CAACE,KAAU,CAACC;AACd,YAAM,IAAI,MAAM,oDAAoD;AAGtE,IAAAnB,EAAI,MAAM,mBAAmB;AAAA,MAC3B,IAAAiB;AAAA,MACA,QAAAC;AAAA,MACA,cAAAC;AAAA,MACA,YAAYC,GAAM,UAAU;AAAA,IAClC,CAAK;AAGD,UAAMC,IAAmB,CAACC,MAAa;AACrC,WAAK,YAAY;AAAA,QACf,IAAAL;AAAA,QACA,QAAQ;AAAA,QACR,UAAU,KAAK,IAAI,KAAK,IAAIK,GAAU,CAAC,GAAG,CAAC;AAAA;AAAA,MACnD,CAAO;AAAA,IACH,GAGMC,IAAkBrB,EAAgBgB,CAAM;AAE9C,QAAI,CAACK;AACH,YAAM,IAAI;AAAA,QACR,WAAWL,CAAM,+CACK,OAAO,KAAKhB,CAAe,EAAE,KAAK,IAAI,CAAC;AAAA,MACrE;AAII,UAAMsB,IAAkBD,EAAgBJ,CAAY;AAEpD,QAAI,CAACK,KAAmB,OAAOA,KAAoB;AACjD,YAAM,IAAI;AAAA,QACR,aAAaL,CAAY,0BAA0BD,CAAM,2BACjC,OAAO,KAAKK,CAAe,EAAE,KAAK,IAAI,CAAC;AAAA,MACvE;AAKI,UAAME,IAAS,MAAMD,EAAgB,GAAGJ,GAAMC,CAAgB;AAG9D,SAAK,YAAY;AAAA,MACf,IAAAJ;AAAA,MACA,QAAQ;AAAA,MACR,QAAAQ;AAAA,IACN,CAAK;AAAA,EAEH,SAASC,GAAO;AAEd,IAAA1B,EAAI,MAAM,eAAe;AAAA,MACvB,IAAAiB;AAAA,MACA,OAAOS,EAAM;AAAA,MACb,OAAOA,EAAM;AAAA,IACnB,CAAK,GACD,KAAK,YAAY;AAAA,MACf,IAAAT;AAAA,MACA,QAAQ;AAAA,MACR,OAAOS,EAAM,WAAW;AAAA,MACxB,OAAOA,EAAM;AAAA,IACnB,CAAK;AAAA,EACH;AACF;AAKA,KAAK,UAAU,SAASA,GAAO;AAC7B,EAAA1B,EAAI,MAAM,gBAAgB;AAAA,IACxB,OAAO0B,EAAM,WAAW;AAAA,IACxB,OAAOA,EAAM;AAAA,EACjB,CAAG,GACD,KAAK,YAAY;AAAA,IACf,QAAQ;AAAA,IACR,OAAOA,EAAM,WAAW;AAAA,EAC5B,CAAG;AACH;AAGA1B,EAAI,KAAK,eAAe,EAAE,aAAa,OAAO,KAAKE,CAAe,EAAE,QAAQ;"}